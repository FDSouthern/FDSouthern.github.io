###### wf.ml:

```
This is the definition of WF.
val ( WF ) : thm =
  |- !(<<). WF (<<) = (!P. (?x. P x) ==> (?x. P x /\ (!y. y << x ==> ~P y)))
```ocaml
```
val ( WF_EQ ) : thm =
  |- WF (<<) = (!P. (?x. P x) = (?x. P x /\ (!y. y << x ==> ~P y)))
val ( WF_IND ) : thm =
  |- WF (<<) = (!P. (!x. (!y. y << x ==> P y) ==> P x) ==> (!x. P x))
val ( WF_DCHAIN ) : thm = |- WF (<<) = ~(?s. !n. s (SUC n) << s n)
val ( WF_UREC ) : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> (f z = g z)) ==> (H f x = H g x))
              ==> (!f g. (!x. f x = H f x) /\ (!x. g x = H g x) ==> (f = g)))
val ( WF_UREC_WF ) : thm =
  |- (!H. (!f g x. (!z. z << x ==> (f z = g z)) ==> (H f x = H g x))
          ==> (!f g. (!x. f x = H f x) /\ (!x. g x = H g x) ==> (f = g)))
     ==> WF (<<)
val ( WF_REC ) : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> (f z = g z)) ==> (H f x = H g x))
              ==> (?f. !x. f x = H f x))
val ( WF_REC_WF ) : thm =
  |- (!H. (!f g x. (!z. z << x ==> (f z = g z)) ==> (H f x = H g x))
          ==> (?f. !x. f x = H f x))
     ==> WF (<<)
val ( WF_EREC ) : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> (f z = g z)) ==> (H f x = H g x))
              ==> (?!f. !x. f x = H f x))
val ( WF_SUBSET ) : thm =
  |- (!x y. x << y ==> x <<< y) /\ WF (<<<) ==> WF (<<)
val ( WF_MEASURE_GEN ) : thm = |- !m. WF (<<) ==> WF (\x x'. m x << m x')
val ( WF_LEX_DEPENDENT ) : thm =
  |- !R S.
         WF R /\ (!a. WF (S a))
         ==> WF (\(r1,s1). \(r2,s2). R r1 r2 \/ (r1 = r2) /\ S r1 s1 s2)
val ( WF_LEX ) : thm =
  |- !R S.
         WF R /\ WF S
         ==> WF (\(r1,s1). \(r2,s2). R r1 r2 \/ (r1 = r2) /\ S s1 s2)
val ( WF_POINTWISE ) : thm =
  |- WF (<<) /\ WF (<<<) ==> WF (\(x1,y1). \(x2,y2). x1 << x2 /\ y1 <<< y2)
val ( WF_num ) : thm = |- WF (<)
val ( WF_REC_num ) : thm =
  |- !H. (!f g n. (!m. m < n ==> (f m = g m)) ==> (H f n = H g n))
         ==> (?f. !n. f n = H f n)
```ocaml
```
This is the definition of measure.
val measure : thm = |- !m. measure m = (\x y. m x < m y)
```ocaml
```
val ( WF_MEASURE ) : thm = |- !m. WF (measure m)
val ( WF_REFL ) : thm = |- !x. WF (<<) ==> ~(x << x)
val ( WF_REC_TAIL ) : thm =
  |- !P g h. ?f. !x. f x = (if P x then f (g x) else h x)
```ocaml
```
WF_INDUCT_THEN
WF_INDUCT_TAC
Perform wellfounded induction over a nominated measure function. Sometimes
avoids explicit "!n t. size(t) = n ==> ..." goal.
```ocaml

###### calc_num.ml:
```ocaml
```
mangle takes a theorem and rewrites its conclusion to elide NUMERAL.
```ocaml
```
val ( ARITH_ZERO ) : thm = |- (NUMERAL 0 = 0) /\ (BIT0 _0 = _0)
val ( ARITH_SUC ) : thm =
  |- (!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
     (SUC _0 = BIT1 _0) /\
     (!n. SUC (BIT0 n) = BIT1 n) /\
     (!n. SUC (BIT1 n) = BIT0 (SUC n))
val ( ARITH_PRE ) : thm =
  |- (!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
     (PRE _0 = _0) /\
     (!n. PRE (BIT0 n) = (if n = _0 then _0 else BIT1 (PRE n))) /\
     (!n. PRE (BIT1 n) = BIT0 n)
val ( ARITH_ADD ) : thm =
  |- (!m n. NUMERAL m + NUMERAL n = NUMERAL (m + n)) /\
     (_0 + _0 = _0) /\
     (!n. _0 + BIT0 n = BIT0 n) /\
     (!n. _0 + BIT1 n = BIT1 n) /\
     (!n. BIT0 n + _0 = BIT0 n) /\
     (!n. BIT1 n + _0 = BIT1 n) /\
     (!m n. BIT0 m + BIT0 n = BIT0 (m + n)) /\
     (!m n. BIT0 m + BIT1 n = BIT1 (m + n)) /\
     (!m n. BIT1 m + BIT0 n = BIT1 (m + n)) /\
     (!m n. BIT1 m + BIT1 n = BIT0 (SUC (m + n)))
val ( ARITH_MULT ) : thm =
  |- (!m n. NUMERAL m * NUMERAL n = NUMERAL (m * n)) /\
     (_0 * _0 = _0) /\
     (!n. _0 * BIT0 n = _0) /\
     (!n. _0 * BIT1 n = _0) /\
     (!n. BIT0 n * _0 = _0) /\
     (!n. BIT1 n * _0 = _0) /\
     (!m n. BIT0 m * BIT0 n = BIT0 (BIT0 (m * n))) /\
     (!m n. BIT0 m * BIT1 n = BIT0 m + BIT0 (BIT0 (m * n))) /\
     (!m n. BIT1 m * BIT0 n = BIT0 n + BIT0 (BIT0 (m * n))) /\
     (!m n. BIT1 m * BIT1 n = BIT1 m + BIT0 n + BIT0 (BIT0 (m * n)))
val ( ARITH_EXP ) : thm =
  |- (!m n. NUMERAL m EXP NUMERAL n = NUMERAL (m EXP n)) /\
     (_0 EXP _0 = BIT1 _0) /\
     (!m. BIT0 m EXP _0 = BIT1 _0) /\
     (!m. BIT1 m EXP _0 = BIT1 _0) /\
     (!n. _0 EXP BIT0 n = _0 EXP n * _0 EXP n) /\
     (!m n. BIT0 m EXP BIT0 n = BIT0 m EXP n * BIT0 m EXP n) /\
     (!m n. BIT1 m EXP BIT0 n = BIT1 m EXP n * BIT1 m EXP n) /\
     (!n. _0 EXP BIT1 n = _0) /\
     (!m n. BIT0 m EXP BIT1 n = BIT0 m * BIT0 m EXP n * BIT0 m EXP n) /\
     (!m n. BIT1 m EXP BIT1 n = BIT1 m * BIT1 m EXP n * BIT1 m EXP n)
val ( ARITH_EVEN ) : thm =
  |- (!n. EVEN (NUMERAL n) = EVEN n) /\
     (EVEN _0 = T) /\
     (!n. EVEN (BIT0 n) = T) /\
     (!n. EVEN (BIT1 n) = F)
val ( ARITH_ODD ) : thm =
  |- (!n. ODD (NUMERAL n) = ODD n) /\
     (ODD _0 = F) /\
     (!n. ODD (BIT0 n) = F) /\
     (!n. ODD (BIT1 n) = T)
val ( ARITH_LE ) : thm =
  |- (!m n. NUMERAL m <= NUMERAL n = m <= n) /\
     (_0 <= _0 = T) /\
     (!n. BIT0 n <= _0 = n = _0) /\
     (!n. BIT1 n <= _0 = F) /\
     (!n. _0 <= BIT0 n = T) /\
     (!n. _0 <= BIT1 n = T) /\
     (!m n. BIT0 m <= BIT0 n = m <= n) /\
     (!m n. BIT0 m <= BIT1 n = m <= n) /\
     (!m n. BIT1 m <= BIT0 n = m < n) /\
     (!m n. BIT1 m <= BIT1 n = m <= n)
val ( ARITH_LT ) : thm =
  |- (!m n. NUMERAL m < NUMERAL n = m < n) /\
     (_0 < _0 = F) /\
     (!n. BIT0 n < _0 = F) /\
     (!n. BIT1 n < _0 = F) /\
     (!n. _0 < BIT0 n = _0 < n) /\
     (!n. _0 < BIT1 n = T) /\
     (!m n. BIT0 m < BIT0 n = m < n) /\
     (!m n. BIT0 m < BIT1 n = m <= n) /\
     (!m n. BIT1 m < BIT0 n = m < n) /\
     (!m n. BIT1 m < BIT1 n = m < n)
val ( ARITH_GE ) : thm =
  |- (!m n. NUMERAL n >= NUMERAL m = n >= m) /\
     _0 >= _0 /\
     (!n. _0 >= BIT0 n = n = _0) /\
     (!n. ~(_0 >= BIT1 n)) /\
     (!n. BIT0 n >= _0) /\
     (!n. BIT1 n >= _0) /\
     (!m n. BIT0 n >= BIT0 m = n >= m) /\
     (!m n. BIT1 n >= BIT0 m = n >= m) /\
     (!m n. BIT0 n >= BIT1 m = n > m) /\
     (!m n. BIT1 n >= BIT1 m = n >= m)
val ( ARITH_GT ) : thm =
  |- (!m n. NUMERAL n > NUMERAL m = n > m) /\
     ~(_0 > _0) /\
     (!n. ~(_0 > BIT0 n)) /\
     (!n. ~(_0 > BIT1 n)) /\
     (!n. BIT0 n > _0 = n > _0) /\
     (!n. BIT1 n > _0) /\
     (!m n. BIT0 n > BIT0 m = n > m) /\
     (!m n. BIT1 n > BIT0 m = n >= m) /\
     (!m n. BIT0 n > BIT1 m = n > m) /\
     (!m n. BIT1 n > BIT1 m = n > m)
val ( ARITH_EQ ) : thm =
  |- (!m n. (NUMERAL m = NUMERAL n) = m = n) /\
     ((_0 = _0) = T) /\
     (!n. (BIT0 n = _0) = n = _0) /\
     (!n. (BIT1 n = _0) = F) /\
     (!n. (_0 = BIT0 n) = _0 = n) /\
     (!n. (_0 = BIT1 n) = F) /\
     (!m n. (BIT0 m = BIT0 n) = m = n) /\
     (!m n. (BIT0 m = BIT1 n) = F) /\
     (!m n. (BIT1 m = BIT0 n) = F) /\
     (!m n. (BIT1 m = BIT1 n) = m = n)
val ( ARITH_SUB ) : thm =
  |- (!m n. NUMERAL m - NUMERAL n = NUMERAL (m - n)) /\
     (_0 - _0 = _0) /\
     (!n. _0 - BIT0 n = _0) /\
     (!n. _0 - BIT1 n = _0) /\
     (!n. BIT0 n - _0 = BIT0 n) /\
     (!n. BIT1 n - _0 = BIT1 n) /\
     (!m n. BIT0 m - BIT0 n = BIT0 (m - n)) /\
     (!m n. BIT0 m - BIT1 n = PRE (BIT0 (m - n))) /\
     (!m n. BIT1 m - BIT0 n = (if n <= m then BIT1 (m - n) else _0)) /\
     (!m n. BIT1 m - BIT1 n = BIT0 (m - n))
val ( ARITH ) : thm =
  |- ((NUMERAL 0 = 0) /\ (BIT0 _0 = _0)) /\
     ((!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
      (SUC _0 = BIT1 _0) /\
      (!n. SUC (BIT0 n) = BIT1 n) /\
      (!n. SUC (BIT1 n) = BIT0 (SUC n))) /\
     ((!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
      (PRE _0 = _0) /\
      (!n. PRE (BIT0 n) = (if n = _0 then _0 else BIT1 (PRE n))) /\
      (!n. PRE (BIT1 n) = BIT0 n)) /\
     ((!m n. NUMERAL m + NUMERAL n = NUMERAL (m + n)) /\
      (_0 + _0 = _0) /\
      (!n. _0 + BIT0 n = BIT0 n) /\
      (!n. _0 + BIT1 n = BIT1 n) /\
      (!n. BIT0 n + _0 = BIT0 n) /\
      (!n. BIT1 n + _0 = BIT1 n) /\
      (!m n. BIT0 m + BIT0 n = BIT0 (m + n)) /\
      (!m n. BIT0 m + BIT1 n = BIT1 (m + n)) /\
      (!m n. BIT1 m + BIT0 n = BIT1 (m + n)) /\
      (!m n. BIT1 m + BIT1 n = BIT0 (SUC (m + n)))) /\
     ((!m n. NUMERAL m * NUMERAL n = NUMERAL (m * n)) /\
      (_0 * _0 = _0) /\
      (!n. _0 * BIT0 n = _0) /\
      (!n. _0 * BIT1 n = _0) /\
      (!n. BIT0 n * _0 = _0) /\
      (!n. BIT1 n * _0 = _0) /\
      (!m n. BIT0 m * BIT0 n = BIT0 (BIT0 (m * n))) /\
      (!m n. BIT0 m * BIT1 n = BIT0 m + BIT0 (BIT0 (m * n))) /\
      (!m n. BIT1 m * BIT0 n = BIT0 n + BIT0 (BIT0 (m * n))) /\
      (!m n. BIT1 m * BIT1 n = BIT1 m + BIT0 n + BIT0 (BIT0 (m * n)))) /\
     ((!m n. NUMERAL m EXP NUMERAL n = NUMERAL (m EXP n)) /\
      (_0 EXP _0 = BIT1 _0) /\
      (!m. BIT0 m EXP _0 = BIT1 _0) /\
      (!m. BIT1 m EXP _0 = BIT1 _0) /\
      (!n. _0 EXP BIT0 n = _0 EXP n * _0 EXP n) /\
      (!m n. BIT0 m EXP BIT0 n = BIT0 m EXP n * BIT0 m EXP n) /\
      (!m n. BIT1 m EXP BIT0 n = BIT1 m EXP n * BIT1 m EXP n) /\
      (!n. _0 EXP BIT1 n = _0) /\
      (!m n. BIT0 m EXP BIT1 n = BIT0 m * BIT0 m EXP n * BIT0 m EXP n) /\
      (!m n. BIT1 m EXP BIT1 n = BIT1 m * BIT1 m EXP n * BIT1 m EXP n)) /\
     ((!n. EVEN (NUMERAL n) = EVEN n) /\
      (EVEN _0 = T) /\
      (!n. EVEN (BIT0 n) = T) /\
      (!n. EVEN (BIT1 n) = F)) /\
     ((!n. ODD (NUMERAL n) = ODD n) /\
      (ODD _0 = F) /\
      (!n. ODD (BIT0 n) = F) /\
      (!n. ODD (BIT1 n) = T)) /\
     ((!m n. (NUMERAL m = NUMERAL n) = m = n) /\
      ((_0 = _0) = T) /\
      (!n. (BIT0 n = _0) = n = _0) /\
      (!n. (BIT1 n = _0) = F) /\
      (!n. (_0 = BIT0 n) = _0 = n) /\
      (!n. (_0 = BIT1 n) = F) /\
      (!m n. (BIT0 m = BIT0 n) = m = n) /\
      (!m n. (BIT0 m = BIT1 n) = F) /\
      (!m n. (BIT1 m = BIT0 n) = F) /\
      (!m n. (BIT1 m = BIT1 n) = m = n)) /\
     ((!m n. NUMERAL m <= NUMERAL n = m <= n) /\
      (_0 <= _0 = T) /\
      (!n. BIT0 n <= _0 = n = _0) /\
      (!n. BIT1 n <= _0 = F) /\
      (!n. _0 <= BIT0 n = T) /\
      (!n. _0 <= BIT1 n = T) /\
      (!m n. BIT0 m <= BIT0 n = m <= n) /\
      (!m n. BIT0 m <= BIT1 n = m <= n) /\
      (!m n. BIT1 m <= BIT0 n = m < n) /\
      (!m n. BIT1 m <= BIT1 n = m <= n)) /\
     ((!m n. NUMERAL m < NUMERAL n = m < n) /\
      (_0 < _0 = F) /\
      (!n. BIT0 n < _0 = F) /\
      (!n. BIT1 n < _0 = F) /\
      (!n. _0 < BIT0 n = _0 < n) /\
      (!n. _0 < BIT1 n = T) /\
      (!m n. BIT0 m < BIT0 n = m < n) /\
      (!m n. BIT0 m < BIT1 n = m <= n) /\
      (!m n. BIT1 m < BIT0 n = m < n) /\
      (!m n. BIT1 m < BIT1 n = m < n)) /\
     ((!m n. NUMERAL n >= NUMERAL m = n >= m) /\
      _0 >= _0 /\
      (!n. _0 >= BIT0 n = n = _0) /\
      (!n. ~(_0 >= BIT1 n)) /\
      (!n. BIT0 n >= _0) /\
      (!n. BIT1 n >= _0) /\
      (!m n. BIT0 n >= BIT0 m = n >= m) /\
      (!m n. BIT1 n >= BIT0 m = n >= m) /\
      (!m n. BIT0 n >= BIT1 m = n > m) /\
      (!m n. BIT1 n >= BIT1 m = n >= m)) /\
     ((!m n. NUMERAL n > NUMERAL m = n > m) /\
      ~(_0 > _0) /\
      (!n. ~(_0 > BIT0 n)) /\
      (!n. ~(_0 > BIT1 n)) /\
      (!n. BIT0 n > _0 = n > _0) /\
      (!n. BIT1 n > _0) /\
      (!m n. BIT0 n > BIT0 m = n > m) /\
      (!m n. BIT1 n > BIT0 m = n >= m) /\
      (!m n. BIT0 n > BIT1 m = n > m) /\
      (!m n. BIT1 n > BIT1 m = n > m)) /\
     (!m n. NUMERAL m - NUMERAL n = NUMERAL (m - n)) /\
     (_0 - _0 = _0) /\
     (!n. _0 - BIT0 n = _0) /\
     (!n. _0 - BIT1 n = _0) /\
     (!n. BIT0 n - _0 = BIT0 n) /\
     (!n. BIT1 n - _0 = BIT1 n) /\
     (!m n. BIT0 m - BIT0 n = BIT0 (m - n)) /\
     (!m n. BIT0 m - BIT1 n = PRE (BIT0 (m - n))) /\
     (!m n. BIT1 m - BIT0 n = (if n <= m then BIT1 (m - n) else _0)) /\
     (!m n. BIT1 m - BIT1 n = BIT0 (m - n))
```ocaml
```
NUM_SUC_CONV rewrites a term of the form `SUC k`, where k is a numeral.
NUM_ADD_CONV rewrites a term of the form `j + k`, where j and k are numerals.
NUM_SUC_CONV' and NUM_ADD_CONV' are the same, except that they expect
numerals without the NUMERAL tag.
```ocaml
```
NUM_PRE_CONV rewrites a term of the form `PRE k`, where k is a numeral.
```ocaml
```
NUM_REL_CONV rewrites a term of the form `j OP k`, where j and k
are numerals, and op is (<), (<=), (>), (>=), (=).
NUM_REL_CONV' is the same, except that it expects numerals without
the NUMERAL tag and does not deal with (>) or (>=).
```ocaml
```
NUM_EQ_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_GE_CONV, NUM_GT_CONV
Like NUM_REL_CONV, but only works if the op matches the conversion
name.  (You could always use NUM_REL_CONV instead of these, unless
you deliberately want to fail on the wrong op.  These will be
very slightly more efficient.)
```ocaml
```
NUM_EVEN_CONV, NUM_ODD_CONV
rewrite terms of the form `EVEN k` and `ODD k` respectively, where k
is a numeral.
```ocaml
```
NUM_SUB_CONV rewrites a term of the form `j - k`, where j and k
are numerals.
```ocaml
```
NUM_MULT_CONV rewrites a term of the form `j * k`, where j and k
are numerals.
NUM_MULT_CONV' is the same, except that it expects numerals without
the NUMERAL tag.
```ocaml
```
NUM_EXP_CONV rewrites a term of the form `j EXP k`, where j and k
are numerals.
```ocaml
```
NUM_DIV_CONV and NUM_MOD_CONV rewrite terms of the forms `j DIV k`
and `j MOD k` respectively, where j and k are numerals.
NUM_DIVMOD_CONV (j:Num.num) (k:Num.num) produces a theorem
`|- (J DIV K = JDIVK) /\ (J MOD K = JMODK)`, where J and K
are the numerals for j and k, and JDIVK and JMODK are the appropriate
numerals.  (NUM_DIV_CONV and NUM_MID_CONV each call this function;
if you need to compute both DIV and MOD, it's about twice as
fast to do both together with NUM_DIVMOD_CONV.)
```ocaml
```
NUM_FACT_CONV rewrites terms of the form `FACT k` where k is a numeral.
```ocaml
```
NUM_RED_CONV reduces `SUC j`, `PRE j`, `FACT j`, `j < k`, `j <= k`,
`j > k`, `j >= k`, `j = k`, `EVEN j`, `ODD j`, `j + k`, `j - k`,
`j * k`, `j EXP k`, `j DIV k`, or `j MOD k` (where j and k are numerals).
```ocaml
```
NUM_REDUCE_CONV reduces the above numeral expressions depth-first
throughout the expression.
```ocaml
```
NUM_REDUCE_TAC reduces numeral expressions in the goal.
```ocaml
```
num_CONV rewrites `j` to `SUC (J-1)`, where J-1 is the numeral for j - 1.
```ocaml
```
EXPAND_CASES_CONV rewrites `!n. n < 5 ==> P[n]` to
`P[0] /\ P[1] /\ P[2] /\ P[3] /\ P[4]`
```ocaml
```
###### ind-types.ml:
```ocaml
```
val ( INJ_INVERSE2 ) : thm =
  |- !P. (!x1 y1 x2 y2. (P x1 y1 = P x2 y2) = (x1 = x2) /\ (y1 = y2))
         ==> (?X Y. !x y. (X (P x y) = x) /\ (Y (P x y) = y))
```ocaml
```
This is the definition of NUMPAIR.
val ( NUMPAIR ) : thm = |- !x y. NUMPAIR x y = 2 EXP x * (2 * y + 1)
```ocaml
```
val ( NUMPAIR_INJ_LEMMA ) : thm =
  |- !x1 y1 x2 y2. (NUMPAIR x1 y1 = NUMPAIR x2 y2) ==> (x1 = x2)
val ( NUMPAIR_INJ ) : thm =
  |- !x1 y1 x2 y2. (NUMPAIR x1 y1 = NUMPAIR x2 y2) = (x1 = x2) /\ (y1 = y2)
```ocaml
```
This is the simultaneous definition of NUMFST and NUMSND (using
new_specification).
val ( NUMPAIR_DEST ) : thm =
  |- !x y. (NUMFST (NUMPAIR x y) = x) /\ (NUMSND (NUMPAIR x y) = y)
```ocaml
```
This is the definition of NUMSUM.
val ( NUMSUM ) : thm =
  |- !b x. NUMSUM b x = (if b then SUC (2 * x) else 2 * x)
```ocaml
```
val ( NUMSUM_INJ ) : thm =
  |- !b1 x1 b2 x2. (NUMSUM b1 x1 = NUMSUM b2 x2) = (b1 = b2) /\ (x1 = x2)
```ocaml
```
This is the simultaneous definition of NUMLEFT and NUMRIGHT
(using new_specification).
val ( NUMSUM_DEST ) : thm =
  |- !x y. (NUMLEFT (NUMSUM x y) = x) /\ (NUMRIGHT (NUMSUM x y) = y)
```ocaml
```
This is the definition of INJN.
val ( INJN ) : thm = |- !m. INJN m = (\n a. n = m)
```ocaml
```
val ( INJN_INJ ) : thm = |- !n1 n2. (INJN n1 = INJN n2) = n1 = n2
```ocaml
```
This is the definition of INJA.
val ( INJA ) : thm = |- !a. INJA a = (\n b. b = a)
```ocaml
```
val ( INJA_INJ ) : thm = |- !a1 a2. (INJA a1 = INJA a2) = a1 = a2
```ocaml
```
This is the definition of INJF.
val ( INJF ) : thm = |- !f. INJF f = (\n. f (NUMFST n) (NUMSND n))
```ocaml
```
val ( INJF_INJ ) : thm = |- !f1 f2. (INJF f1 = INJF f2) = f1 = f2
```ocaml
```
This is the definition of INJP.
val ( INJP ) : thm =
  |- !f1 f2.
         INJP f1 f2 =
         (\n a. if NUMLEFT n then f1 (NUMRIGHT n) a else f2 (NUMRIGHT n) a)
```ocaml
```
val ( INJP_INJ ) : thm =
  |- !f1 f1' f2 f2'. (INJP f1 f2 = INJP f1' f2') = (f1 = f1') /\ (f2 = f2')
```ocaml
```
These are the definitions of ZCONSTR and ZBOT.
val ( ZCONSTR ) : thm =
  |- !c i r. ZCONSTR c i r = INJP (INJN (SUC c)) (INJP (INJA i) (INJF r))
val ( ZBOT ) : thm = |- ZBOT = INJP (INJN 0) (@z. T)
```ocaml
```
val ( ZCONSTR_ZBOT ) : thm = |- !c i r. ~(ZCONSTR c i r = ZBOT)
```ocaml
```
This is the definition (via new_inductive_definition) of
ZRECSPACE_ZBOT.
val ( ZRECSPACE_RULES ) : thm =
  |- ZRECSPACE ZBOT /\
     (!c i r. (!n. ZRECSPACE (r n)) ==> ZRECSPACE (ZCONSTR c i r))
val ( ZRECSPACE_INDUCT ) : thm =
  |- !ZRECSPACE'. ZRECSPACE' ZBOT /\
                  (!c i r.
                       (!n. ZRECSPACE' (r n)) ==> ZRECSPACE' (ZCONSTR c i r))
                  ==> (!a. ZRECSPACE a ==> ZRECSPACE' a)
val ( ZRECSPACE_CASES ) : thm =
  |- !a. ZRECSPACE a =
         (a = ZBOT) \/ (?c i r. (a = ZCONSTR c i r) /\ (!n. ZRECSPACE (r n)))
```ocaml
```
This is the definition of a new type, "(A)recspace"; and its in and out
functions, "_mk_rec" and "_dest_rec".
val recspace_tydef : thm * thm =
  (|- _mk_rec (_dest_rec a) = a, |- ZRECSPACE r = _dest_rec (_mk_rec r) = r)
```ocaml
```
These are the definitions of BOTTOM and CONSTR.
val ( BOTTOM ) : thm = |- BOTTOM = _mk_rec ZBOT
val ( CONSTR ) : thm =
  |- !c i r. CONSTR c i r = _mk_rec (ZCONSTR c i (\n. _dest_rec (r n)))
```ocaml
```
val ( MK_REC_INJ ) : thm =
  |- !x y. (_mk_rec x = _mk_rec y) ==> ZRECSPACE x /\ ZRECSPACE y ==> (x = y)
val ( DEST_REC_INJ ) : thm = |- !x y. (_dest_rec x = _dest_rec y) = x = y
val ( CONSTR_BOT ) : thm = |- !c i r. ~(CONSTR c i r = BOTTOM)
val ( CONSTR_INJ ) : thm =
  |- !c1 i1 r1 c2 i2 r2.
         (CONSTR c1 i1 r1 = CONSTR c2 i2 r2) =
         (c1 = c2) /\ (i1 = i2) /\ (r1 = r2)
val ( CONSTR_IND ) : thm =
  |- !P. P BOTTOM /\ (!c i r. (!n. P (r n)) ==> P (CONSTR c i r))
         ==> (!x. P x)
val ( CONSTR_REC ) : thm =
  |- !Fn. ?f. !c i r. f (CONSTR c i r) = Fn c i r (\n. f (r n))
```ocaml
```
This is the definition of FCONS.
val ( FCONS ) : thm =
  |- (!a f. FCONS a f 0 = a) /\ (!a f n. FCONS a f (SUC n) = f n)
```ocaml
```
val ( FCONS_UNDO ) : thm = |- !f. f = FCONS (f 0) (f o SUC)
```ocaml
```
This is the definition of FNIL.
val ( FNIL ) : thm = |- !n. FNIL n = (@x. T)
```ocaml
```
sucivate 5 = `SUC (SUC (SUC (SUC (SUC 0))))`
(for example)
```ocaml
```
SCRUB_EQUATION `x = a` `x = a |- P[x]``` gives ```|- P[a]`
```ocaml
```
###### list.ml:
```ocaml
```
LIST_INDUCT_TAC takes a goal of the form `!l. P[l]` and creates two
subgoals: `P[ [] ]` and `P[CONS h t]`.  The latter subgoal has a new
assumption `P[t]`.
```ocaml
```
Definitions of list-related functions:
val ( HD ) : thm = |- HD (CONS h t) = h
val ( TL ) : thm = |- TL (CONS h t) = t
val ( APPEND ) : thm =
  |- (!l. APPEND [] l = l) /\
     (!h t l. APPEND (CONS h t) l = CONS h (APPEND t l))
val ( REVERSE ) : thm =
  |- (REVERSE [] = []) /\ (REVERSE (CONS x l) = APPEND (REVERSE l) [x])
val ( LENGTH ) : thm =
  |- (LENGTH [] = 0) /\ (!h t. LENGTH (CONS h t) = SUC (LENGTH t))
val ( MAP ) : thm =
  |- (!f. MAP f [] = []) /\ (!f h t. MAP f (CONS h t) = CONS (f h) (MAP f t))
val ( LAST ) : thm = |- LAST (CONS h t) = (if t = [] then h else LAST t)
val ( REPLICATE ) : thm =
  |- (REPLICATE 0 x = []) /\ (REPLICATE (SUC n) x = CONS x (REPLICATE n x))
val ( NULL ) : thm = |- (NULL [] = T) /\ (NULL (CONS h t) = F)
val ( ALL ) : thm = |- (ALL P [] = T) /\ (ALL P (CONS h t) = P h /\ ALL P t)
val ( EX ) : thm = |- (EX P [] = F) /\ (EX P (CONS h t) = P h \/ EX P t)
val ( ITLIST ) : thm =
  |- (ITLIST f [] b = b) /\ (ITLIST f (CONS h t) b = f h (ITLIST f t b))
val ( MEM ) : thm =
  |- (MEM x [] = F) /\ (MEM x (CONS h t) = (x = h) \/ MEM x t)
val ( ALL2_DEF ) : thm =
  |- (ALL2 P [] l2 = l2 = []) /\
     (ALL2 P (CONS h1 t1) l2 =
      (if l2 = [] then F else P h1 (HD l2) /\ ALL2 P t1 (TL l2)))
val ( MAP2_DEF ) : thm =
  |- (MAP2 f [] l = []) /\
     (MAP2 f (CONS h1 t1) l = CONS (f h1 (HD l)) (MAP2 f t1 (TL l)))
val ( EL ) : thm = |- (EL 0 l = HD l) /\ (EL (SUC n) l = EL n (TL l))
val ( FILTER ) : thm =
  |- (FILTER P [] = []) /\
     (FILTER P (CONS h t) =
      (if P h then CONS h (FILTER P t) else FILTER P t))
val ( ASSOC ) : thm =
  |- ASSOC a (CONS h t) = (if FST h = a then SND h else ASSOC a t)
val ( ITLIST2_DEF ) : thm =
  |- (ITLIST2 f [] l2 b = b) /\
     (ITLIST2 f (CONS h1 t1) l2 b = f h1 (HD l2) (ITLIST2 f t1 (TL l2) b))
val ( ZIP_DEF ) : thm =
  |- (ZIP [] l2 = []) /\
     (ZIP (CONS h1 t1) l2 = CONS (h1,HD l2) (ZIP t1 (TL l2)))
```ocaml
```
More convenient forms of some of the above:
val ( ALL2 ) : thm =
  |- (ALL2 P [] [] = T) /\
     (ALL2 P (CONS h1 t1) [] = F) /\
     (ALL2 P [] (CONS h2 t2) = F) /\
     (ALL2 P (CONS h1 t1) (CONS h2 t2) = P h1 h2 /\ ALL2 P t1 t2)
val ( MAP2 ) : thm =
  |- (MAP2 f [] [] = []) /\
     (MAP2 f (CONS h1 t1) (CONS h2 t2) = CONS (f h1 h2) (MAP2 f t1 t2))
val ( ITLIST2 ) : thm =
  |- (ITLIST2 f [] [] b = b) /\
     (ITLIST2 f (CONS h1 t1) (CONS h2 t2) b = f h1 h2 (ITLIST2 f t1 t2 b))
val ( ZIP ) : thm =
  |- (ZIP [] [] = []) /\
     (ZIP (CONS h1 t1) (CONS h2 t2) = CONS (h1,h2) (ZIP t1 t2))
```ocaml
```
val ( NOT_CONS_NIL ) : thm = |- !h t. ~(CONS h t = [])
val ( LAST_CLAUSES ) : thm =
  |- (LAST [h] = h) /\ (LAST (CONS h (CONS k t)) = LAST (CONS k t))
val ( APPEND_NIL ) : thm = |- !l. APPEND l [] = l
val ( APPEND_ASSOC ) : thm =
  |- !l m n. APPEND l (APPEND m n) = APPEND (APPEND l m) n
val ( REVERSE_APPEND ) : thm =
  |- !l m. REVERSE (APPEND l m) = APPEND (REVERSE m) (REVERSE l)
val ( REVERSE_REVERSE ) : thm = |- !l. REVERSE (REVERSE l) = l
val ( CONS_11 ) : thm =
  |- !h1 h2 t1 t2. (CONS h1 t1 = CONS h2 t2) = (h1 = h2) /\ (t1 = t2)
val list_CASES : thm = |- !l. (l = []) \/ (?h t. l = CONS h t)
val ( LENGTH_APPEND ) : thm =
  |- !l m. LENGTH (APPEND l m) = LENGTH l + LENGTH m
val ( MAP_APPEND ) : thm =
  |- !f l1 l2. MAP f (APPEND l1 l2) = APPEND (MAP f l1) (MAP f l2)
val ( LENGTH_MAP ) : thm = |- !l f. LENGTH (MAP f l) = LENGTH l
val ( LENGTH_EQ_NIL ) : thm = |- !l. (LENGTH l = 0) = l = []
val ( MAP_o ) : thm = |- !f g l. MAP (g o f) l = MAP g (MAP f l)
val ( MAP_EQ ) : thm =
  |- !f g l. ALL (\x. f x = g x) l ==> (MAP f l = MAP g l)
val ( ALL_IMP ) : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ ALL P l ==> ALL Q l
val ( NOT_EX ) : thm = |- !P l. ~EX P l = ALL (\x. ~P x) l
val ( NOT_ALL ) : thm = |- !P l. ~ALL P l = EX (\x. ~P x) l
val ( ALL_MAP ) : thm = |- !P f l. ALL P (MAP f l) = ALL (P o f) l
val ( ALL_T ) : thm = |- !l. ALL (\x. T) l
val ( MAP_EQ_ALL2 ) : thm =
  |- !l m. ALL2 (\x y. f x = f y) l m ==> (MAP f l = MAP f m)
val ( ALL2_MAP ) : thm =
  |- !P f l. ALL2 P (MAP f l) l = ALL (\a. P (f a) a) l
val ( MAP_EQ_DEGEN ) : thm = |- !l f. ALL (\x. f x = x) l ==> (MAP f l = l)
val ( ALL2_AND_RIGHT ) : thm =
  |- !l m P Q. ALL2 (\x y. P x /\ Q x y) l m = ALL P l /\ ALL2 Q l m
val ( ITLIST_EXTRA ) : thm =
  |- !l. ITLIST f (APPEND l [a]) b = ITLIST f l (f a b)
val ( ALL_MP ) : thm =
  |- !P Q l. ALL (\x. P x ==> Q x) l /\ ALL P l ==> ALL Q l
val ( FORALL_ALL ) : thm = |- !l. (!x. ALL (P x) l) = ALL (\a. !x. P x a) l
val ( AND_ALL ) : thm = |- !l. ALL P l /\ ALL Q l = ALL (\x. P x /\ Q x) l
val ( EX_IMP ) : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ EX P l ==> EX Q l
val ( ALL_MEM ) : thm = |- !P l. (!x. MEM x l ==> P x) = ALL P l
val ( LENGTH_REPLICATE ) : thm = |- !n x. LENGTH (REPLICATE n x) = n
val ( EX_MAP ) : thm = |- !P f l. EX P (MAP f l) = EX (P o f) l
val ( EXISTS_EX ) : thm = |- !P l. (?x. EX (P x) l) = EX (\s. ?x. P x s) l
val ( FORALL_ALL ) : thm = |- !P l. (!x. ALL (P x) l) = ALL (\s. !x. P x s) l
val ( MEM_APPEND ) : thm =
  |- !x l1 l2. MEM x (APPEND l1 l2) = MEM x l1 \/ MEM x l2
val ( MEM_MAP ) : thm =
  |- !f y l. MEM y (MAP f l) = (?x. MEM x l /\ (y = f x))
val ( FILTER_APPEND ) : thm =
  |- !P l1 l2. FILTER P (APPEND l1 l2) = APPEND (FILTER P l1) (FILTER P l2)
val ( FILTER_MAP ) : thm =
  |- !P f l. FILTER P (MAP f l) = MAP f (FILTER (P o f) l)
val ( MEM_FILTER ) : thm = |- !P l x. MEM x (FILTER P l) = P x /\ MEM x l
val ( EX_MEM ) : thm = |- !P l. EX P l = (?x. P x /\ MEM x l)
val ( MAP_FST_ZIP ) : thm =
  |- !l1 l2. (LENGTH l1 = LENGTH l2) ==> (MAP FST (ZIP l1 l2) = l1)
val ( MAP_SND_ZIP ) : thm =
  |- !l1 l2. (LENGTH l1 = LENGTH l2) ==> (MAP SND (ZIP l1 l2) = l2)
val ( MEM_ASSOC ) : thm = |- !l x. MEM (x,ASSOC x l) l = MEM x (MAP FST l)
val ( ALL_APPEND ) : thm =
  |- !P l1 l2. ALL P (APPEND l1 l2) = ALL P l1 /\ ALL P l2
val ( MEM_EL ) : thm = |- !l n. n < LENGTH l ==> MEM (EL n l) l
val ( ALL2_MAP2 ) : thm =
  |- !l m. ALL2 P (MAP f l) (MAP g m) = ALL2 (\x y. P (f x) (g y)) l m
val ( AND_ALL2 ) : thm =
  |- !P Q l m. ALL2 P l m /\ ALL2 Q l m = ALL2 (\x y. P x y /\ Q x y) l m
val ( ALL2_ALL ) : thm = |- !P l. ALL2 P l l = ALL (\x. P x x) l
val ( APPEND_EQ_NIL ) : thm =
  |- !l m. (APPEND l m = []) = (l = []) /\ (m = [])
```ocaml
```
val ( MONO_ALL ) : thm = |- (!x. P x ==> Q x) ==> ALL P l ==> ALL Q l
val ( MONO_ALL2 ) : thm =
  |- (!x y. P x y ==> Q x y) ==> ALL2 P l l' ==> ALL2 Q l l'
MONO_ALL and MONO_ALL2 will automatically be used by MONO_TAC.
```ocaml
```
LIST_CONV conv uses conv to rewrite every member of a (literal) list.
```ocaml
```
###### realax.ml:
The operators +,-,*,<,<=,>,>= are overloaded; there are versions for
num, real, int.  If an expression does not make it clear which type is
used, they default to the current "prioritized" type.
```ocaml
```
pioritize_num() sets operator overloading to default to the type num.
```ocaml
```
This is the definition of dist.
val dist : thm = |- !n m. dist (m,n) = m - n + n - m
```ocaml
```
val ( DIST_REFL ) : thm = |- !n. dist (n,n) = 0
val ( DIST_LZERO ) : thm = |- !n. dist (0,n) = n
val ( DIST_RZERO ) : thm = |- !n. dist (n,0) = n
val ( DIST_SYM ) : thm = |- !m n. dist (m,n) = dist (n,m)
val ( DIST_LADD ) : thm = |- !m p n. dist (m + n,m + p) = dist (n,p)
val ( DIST_RADD ) : thm = |- !m p n. dist (m + p,n + p) = dist (m,n)
val ( DIST_LADD_0 ) : thm = |- !m n. dist (m + n,m) = n
val ( DIST_RADD_0 ) : thm = |- !m n. dist (m,m + n) = n
val ( DIST_LMUL ) : thm = |- !m n p. m * dist (n,p) = dist (m * n,m * p)
val ( DIST_RMUL ) : thm = |- !m n p. dist (m,n) * p = dist (m * p,n * p)
val ( DIST_EQ_0 ) : thm = |- !m n. (dist (m,n) = 0) = m = n
val ( DIST_ELIM_THM ) : thm =
  |- P (dist (x,y)) = (!d. ((x = y + d) ==> P d) /\ ((y = x + d) ==> P d))
