###### ind-types.ml:
```ocaml
```
val ( INJ_INVERSE2 ) : thm =
  |- !P. (!x1 y1 x2 y2. (P x1 y1 = P x2 y2) = (x1 = x2) /\ (y1 = y2))
         ==> (?X Y. !x y. (X (P x y) = x) /\ (Y (P x y) = y))
```ocaml
```
This is the definition of NUMPAIR.
val ( NUMPAIR ) : thm = |- !x y. NUMPAIR x y = 2 EXP x * (2 * y + 1)
```ocaml
```
val ( NUMPAIR_INJ_LEMMA ) : thm =
  |- !x1 y1 x2 y2. (NUMPAIR x1 y1 = NUMPAIR x2 y2) ==> (x1 = x2)
val ( NUMPAIR_INJ ) : thm =
  |- !x1 y1 x2 y2. (NUMPAIR x1 y1 = NUMPAIR x2 y2) = (x1 = x2) /\ (y1 = y2)
```ocaml
```
This is the simultaneous definition of NUMFST and NUMSND (using
new_specification).
val ( NUMPAIR_DEST ) : thm =
  |- !x y. (NUMFST (NUMPAIR x y) = x) /\ (NUMSND (NUMPAIR x y) = y)
```ocaml
```
This is the definition of NUMSUM.
val ( NUMSUM ) : thm =
  |- !b x. NUMSUM b x = (if b then SUC (2 * x) else 2 * x)
```ocaml
```
val ( NUMSUM_INJ ) : thm =
  |- !b1 x1 b2 x2. (NUMSUM b1 x1 = NUMSUM b2 x2) = (b1 = b2) /\ (x1 = x2)
```ocaml
```
This is the simultaneous definition of NUMLEFT and NUMRIGHT
(using new_specification).
val ( NUMSUM_DEST ) : thm =
  |- !x y. (NUMLEFT (NUMSUM x y) = x) /\ (NUMRIGHT (NUMSUM x y) = y)
```ocaml
```
This is the definition of INJN.
val ( INJN ) : thm = |- !m. INJN m = (\n a. n = m)
```ocaml
```
val ( INJN_INJ ) : thm = |- !n1 n2. (INJN n1 = INJN n2) = n1 = n2
```ocaml
```
This is the definition of INJA.
val ( INJA ) : thm = |- !a. INJA a = (\n b. b = a)
```ocaml
```
val ( INJA_INJ ) : thm = |- !a1 a2. (INJA a1 = INJA a2) = a1 = a2
```ocaml
```
This is the definition of INJF.
val ( INJF ) : thm = |- !f. INJF f = (\n. f (NUMFST n) (NUMSND n))
```ocaml
```
val ( INJF_INJ ) : thm = |- !f1 f2. (INJF f1 = INJF f2) = f1 = f2
```ocaml
```
This is the definition of INJP.
val ( INJP ) : thm =
  |- !f1 f2.
         INJP f1 f2 =
         (\n a. if NUMLEFT n then f1 (NUMRIGHT n) a else f2 (NUMRIGHT n) a)
```ocaml
```
val ( INJP_INJ ) : thm =
  |- !f1 f1' f2 f2'. (INJP f1 f2 = INJP f1' f2') = (f1 = f1') /\ (f2 = f2')
```ocaml
```
These are the definitions of ZCONSTR and ZBOT.
val ( ZCONSTR ) : thm =
  |- !c i r. ZCONSTR c i r = INJP (INJN (SUC c)) (INJP (INJA i) (INJF r))
val ( ZBOT ) : thm = |- ZBOT = INJP (INJN 0) (@z. T)
```ocaml
```
val ( ZCONSTR_ZBOT ) : thm = |- !c i r. ~(ZCONSTR c i r = ZBOT)
```ocaml
```
This is the definition (via new_inductive_definition) of
ZRECSPACE_ZBOT.
val ( ZRECSPACE_RULES ) : thm =
  |- ZRECSPACE ZBOT /\
     (!c i r. (!n. ZRECSPACE (r n)) ==> ZRECSPACE (ZCONSTR c i r))
val ( ZRECSPACE_INDUCT ) : thm =
  |- !ZRECSPACE'. ZRECSPACE' ZBOT /\
                  (!c i r.
                       (!n. ZRECSPACE' (r n)) ==> ZRECSPACE' (ZCONSTR c i r))
                  ==> (!a. ZRECSPACE a ==> ZRECSPACE' a)
val ( ZRECSPACE_CASES ) : thm =
  |- !a. ZRECSPACE a =
         (a = ZBOT) \/ (?c i r. (a = ZCONSTR c i r) /\ (!n. ZRECSPACE (r n)))
```ocaml
```
This is the definition of a new type, "(A)recspace"; and its in and out
functions, "_mk_rec" and "_dest_rec".
val recspace_tydef : thm * thm =
  (|- _mk_rec (_dest_rec a) = a, |- ZRECSPACE r = _dest_rec (_mk_rec r) = r)
```ocaml
```
These are the definitions of BOTTOM and CONSTR.
val ( BOTTOM ) : thm = |- BOTTOM = _mk_rec ZBOT
val ( CONSTR ) : thm =
  |- !c i r. CONSTR c i r = _mk_rec (ZCONSTR c i (\n. _dest_rec (r n)))
```ocaml
```
val ( MK_REC_INJ ) : thm =
  |- !x y. (_mk_rec x = _mk_rec y) ==> ZRECSPACE x /\ ZRECSPACE y ==> (x = y)
val ( DEST_REC_INJ ) : thm = |- !x y. (_dest_rec x = _dest_rec y) = x = y
val ( CONSTR_BOT ) : thm = |- !c i r. ~(CONSTR c i r = BOTTOM)
val ( CONSTR_INJ ) : thm =
  |- !c1 i1 r1 c2 i2 r2.
         (CONSTR c1 i1 r1 = CONSTR c2 i2 r2) =
         (c1 = c2) /\ (i1 = i2) /\ (r1 = r2)
val ( CONSTR_IND ) : thm =
  |- !P. P BOTTOM /\ (!c i r. (!n. P (r n)) ==> P (CONSTR c i r))
         ==> (!x. P x)
val ( CONSTR_REC ) : thm =
  |- !Fn. ?f. !c i r. f (CONSTR c i r) = Fn c i r (\n. f (r n))
```ocaml
```
This is the definition of FCONS.
val ( FCONS ) : thm =
  |- (!a f. FCONS a f 0 = a) /\ (!a f n. FCONS a f (SUC n) = f n)
```ocaml
```
val ( FCONS_UNDO ) : thm = |- !f. f = FCONS (f 0) (f o SUC)
```ocaml
```
This is the definition of FNIL.
val ( FNIL ) : thm = |- !n. FNIL n = (@x. T)
```ocaml
```
sucivate 5 = `SUC (SUC (SUC (SUC (SUC 0))))`
(for example)
```ocaml
```
SCRUB_EQUATION `x = a` `x = a |- P[x]``` gives ```|- P[a]`
```ocaml
```
###### list.ml:
```ocaml
```
LIST_INDUCT_TAC takes a goal of the form `!l. P[l]` and creates two
subgoals: `P[ [] ]` and `P[CONS h t]`.  The latter subgoal has a new
assumption `P[t]`.
```ocaml
```
Definitions of list-related functions:
val ( HD ) : thm = |- HD (CONS h t) = h
val ( TL ) : thm = |- TL (CONS h t) = t
val ( APPEND ) : thm =
  |- (!l. APPEND [] l = l) /\
     (!h t l. APPEND (CONS h t) l = CONS h (APPEND t l))
val ( REVERSE ) : thm =
  |- (REVERSE [] = []) /\ (REVERSE (CONS x l) = APPEND (REVERSE l) [x])
val ( LENGTH ) : thm =
  |- (LENGTH [] = 0) /\ (!h t. LENGTH (CONS h t) = SUC (LENGTH t))
val ( MAP ) : thm =
  |- (!f. MAP f [] = []) /\ (!f h t. MAP f (CONS h t) = CONS (f h) (MAP f t))
val ( LAST ) : thm = |- LAST (CONS h t) = (if t = [] then h else LAST t)
val ( REPLICATE ) : thm =
  |- (REPLICATE 0 x = []) /\ (REPLICATE (SUC n) x = CONS x (REPLICATE n x))
val ( NULL ) : thm = |- (NULL [] = T) /\ (NULL (CONS h t) = F)
val ( ALL ) : thm = |- (ALL P [] = T) /\ (ALL P (CONS h t) = P h /\ ALL P t)
val ( EX ) : thm = |- (EX P [] = F) /\ (EX P (CONS h t) = P h \/ EX P t)
val ( ITLIST ) : thm =
  |- (ITLIST f [] b = b) /\ (ITLIST f (CONS h t) b = f h (ITLIST f t b))
val ( MEM ) : thm =
  |- (MEM x [] = F) /\ (MEM x (CONS h t) = (x = h) \/ MEM x t)
val ( ALL2_DEF ) : thm =
  |- (ALL2 P [] l2 = l2 = []) /\
     (ALL2 P (CONS h1 t1) l2 =
      (if l2 = [] then F else P h1 (HD l2) /\ ALL2 P t1 (TL l2)))
val ( MAP2_DEF ) : thm =
  |- (MAP2 f [] l = []) /\
     (MAP2 f (CONS h1 t1) l = CONS (f h1 (HD l)) (MAP2 f t1 (TL l)))
val ( EL ) : thm = |- (EL 0 l = HD l) /\ (EL (SUC n) l = EL n (TL l))
val ( FILTER ) : thm =
  |- (FILTER P [] = []) /\
     (FILTER P (CONS h t) =
      (if P h then CONS h (FILTER P t) else FILTER P t))
val ( ASSOC ) : thm =
  |- ASSOC a (CONS h t) = (if FST h = a then SND h else ASSOC a t)
val ( ITLIST2_DEF ) : thm =
  |- (ITLIST2 f [] l2 b = b) /\
     (ITLIST2 f (CONS h1 t1) l2 b = f h1 (HD l2) (ITLIST2 f t1 (TL l2) b))
val ( ZIP_DEF ) : thm =
  |- (ZIP [] l2 = []) /\
     (ZIP (CONS h1 t1) l2 = CONS (h1,HD l2) (ZIP t1 (TL l2)))
```ocaml
```
More convenient forms of some of the above:
val ( ALL2 ) : thm =
  |- (ALL2 P [] [] = T) /\
     (ALL2 P (CONS h1 t1) [] = F) /\
     (ALL2 P [] (CONS h2 t2) = F) /\
     (ALL2 P (CONS h1 t1) (CONS h2 t2) = P h1 h2 /\ ALL2 P t1 t2)
val ( MAP2 ) : thm =
  |- (MAP2 f [] [] = []) /\
     (MAP2 f (CONS h1 t1) (CONS h2 t2) = CONS (f h1 h2) (MAP2 f t1 t2))
val ( ITLIST2 ) : thm =
  |- (ITLIST2 f [] [] b = b) /\
     (ITLIST2 f (CONS h1 t1) (CONS h2 t2) b = f h1 h2 (ITLIST2 f t1 t2 b))
val ( ZIP ) : thm =
  |- (ZIP [] [] = []) /\
     (ZIP (CONS h1 t1) (CONS h2 t2) = CONS (h1,h2) (ZIP t1 t2))
```ocaml
```
val ( NOT_CONS_NIL ) : thm = |- !h t. ~(CONS h t = [])
val ( LAST_CLAUSES ) : thm =
  |- (LAST [h] = h) /\ (LAST (CONS h (CONS k t)) = LAST (CONS k t))
val ( APPEND_NIL ) : thm = |- !l. APPEND l [] = l
val ( APPEND_ASSOC ) : thm =
  |- !l m n. APPEND l (APPEND m n) = APPEND (APPEND l m) n
val ( REVERSE_APPEND ) : thm =
  |- !l m. REVERSE (APPEND l m) = APPEND (REVERSE m) (REVERSE l)
val ( REVERSE_REVERSE ) : thm = |- !l. REVERSE (REVERSE l) = l
val ( CONS_11 ) : thm =
  |- !h1 h2 t1 t2. (CONS h1 t1 = CONS h2 t2) = (h1 = h2) /\ (t1 = t2)
val list_CASES : thm = |- !l. (l = []) \/ (?h t. l = CONS h t)
val ( LENGTH_APPEND ) : thm =
  |- !l m. LENGTH (APPEND l m) = LENGTH l + LENGTH m
val ( MAP_APPEND ) : thm =
  |- !f l1 l2. MAP f (APPEND l1 l2) = APPEND (MAP f l1) (MAP f l2)
val ( LENGTH_MAP ) : thm = |- !l f. LENGTH (MAP f l) = LENGTH l
val ( LENGTH_EQ_NIL ) : thm = |- !l. (LENGTH l = 0) = l = []
val ( MAP_o ) : thm = |- !f g l. MAP (g o f) l = MAP g (MAP f l)
val ( MAP_EQ ) : thm =
  |- !f g l. ALL (\x. f x = g x) l ==> (MAP f l = MAP g l)
val ( ALL_IMP ) : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ ALL P l ==> ALL Q l
val ( NOT_EX ) : thm = |- !P l. ~EX P l = ALL (\x. ~P x) l
val ( NOT_ALL ) : thm = |- !P l. ~ALL P l = EX (\x. ~P x) l
val ( ALL_MAP ) : thm = |- !P f l. ALL P (MAP f l) = ALL (P o f) l
val ( ALL_T ) : thm = |- !l. ALL (\x. T) l
val ( MAP_EQ_ALL2 ) : thm =
  |- !l m. ALL2 (\x y. f x = f y) l m ==> (MAP f l = MAP f m)
val ( ALL2_MAP ) : thm =
  |- !P f l. ALL2 P (MAP f l) l = ALL (\a. P (f a) a) l
val ( MAP_EQ_DEGEN ) : thm = |- !l f. ALL (\x. f x = x) l ==> (MAP f l = l)
val ( ALL2_AND_RIGHT ) : thm =
  |- !l m P Q. ALL2 (\x y. P x /\ Q x y) l m = ALL P l /\ ALL2 Q l m
val ( ITLIST_EXTRA ) : thm =
  |- !l. ITLIST f (APPEND l [a]) b = ITLIST f l (f a b)
val ( ALL_MP ) : thm =
  |- !P Q l. ALL (\x. P x ==> Q x) l /\ ALL P l ==> ALL Q l
val ( FORALL_ALL ) : thm = |- !l. (!x. ALL (P x) l) = ALL (\a. !x. P x a) l
val ( AND_ALL ) : thm = |- !l. ALL P l /\ ALL Q l = ALL (\x. P x /\ Q x) l
val ( EX_IMP ) : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ EX P l ==> EX Q l
val ( ALL_MEM ) : thm = |- !P l. (!x. MEM x l ==> P x) = ALL P l
val ( LENGTH_REPLICATE ) : thm = |- !n x. LENGTH (REPLICATE n x) = n
val ( EX_MAP ) : thm = |- !P f l. EX P (MAP f l) = EX (P o f) l
val ( EXISTS_EX ) : thm = |- !P l. (?x. EX (P x) l) = EX (\s. ?x. P x s) l
val ( FORALL_ALL ) : thm = |- !P l. (!x. ALL (P x) l) = ALL (\s. !x. P x s) l
val ( MEM_APPEND ) : thm =
  |- !x l1 l2. MEM x (APPEND l1 l2) = MEM x l1 \/ MEM x l2
val ( MEM_MAP ) : thm =
  |- !f y l. MEM y (MAP f l) = (?x. MEM x l /\ (y = f x))
val ( FILTER_APPEND ) : thm =
  |- !P l1 l2. FILTER P (APPEND l1 l2) = APPEND (FILTER P l1) (FILTER P l2)
val ( FILTER_MAP ) : thm =
  |- !P f l. FILTER P (MAP f l) = MAP f (FILTER (P o f) l)
val ( MEM_FILTER ) : thm = |- !P l x. MEM x (FILTER P l) = P x /\ MEM x l
val ( EX_MEM ) : thm = |- !P l. EX P l = (?x. P x /\ MEM x l)
val ( MAP_FST_ZIP ) : thm =
  |- !l1 l2. (LENGTH l1 = LENGTH l2) ==> (MAP FST (ZIP l1 l2) = l1)
val ( MAP_SND_ZIP ) : thm =
  |- !l1 l2. (LENGTH l1 = LENGTH l2) ==> (MAP SND (ZIP l1 l2) = l2)
val ( MEM_ASSOC ) : thm = |- !l x. MEM (x,ASSOC x l) l = MEM x (MAP FST l)
val ( ALL_APPEND ) : thm =
  |- !P l1 l2. ALL P (APPEND l1 l2) = ALL P l1 /\ ALL P l2
val ( MEM_EL ) : thm = |- !l n. n < LENGTH l ==> MEM (EL n l) l
val ( ALL2_MAP2 ) : thm =
  |- !l m. ALL2 P (MAP f l) (MAP g m) = ALL2 (\x y. P (f x) (g y)) l m
val ( AND_ALL2 ) : thm =
  |- !P Q l m. ALL2 P l m /\ ALL2 Q l m = ALL2 (\x y. P x y /\ Q x y) l m
val ( ALL2_ALL ) : thm = |- !P l. ALL2 P l l = ALL (\x. P x x) l
val ( APPEND_EQ_NIL ) : thm =
  |- !l m. (APPEND l m = []) = (l = []) /\ (m = [])
```ocaml
```
val ( MONO_ALL ) : thm = |- (!x. P x ==> Q x) ==> ALL P l ==> ALL Q l
val ( MONO_ALL2 ) : thm =
  |- (!x y. P x y ==> Q x y) ==> ALL2 P l l' ==> ALL2 Q l l'
MONO_ALL and MONO_ALL2 will automatically be used by MONO_TAC.
```ocaml
```
LIST_CONV conv uses conv to rewrite every member of a (literal) list.
```ocaml
```
###### realax.ml:
The operators +,-,*,<,<=,>,>= are overloaded; there are versions for
num, real, int.  If an expression does not make it clear which type is
used, they default to the current "prioritized" type.
```ocaml
```
pioritize_num() sets operator overloading to default to the type num.
```ocaml
```
This is the definition of dist.
val dist : thm = |- !n m. dist (m,n) = m - n + n - m
```ocaml
```
val ( DIST_REFL ) : thm = |- !n. dist (n,n) = 0
val ( DIST_LZERO ) : thm = |- !n. dist (0,n) = n
val ( DIST_RZERO ) : thm = |- !n. dist (n,0) = n
val ( DIST_SYM ) : thm = |- !m n. dist (m,n) = dist (n,m)
val ( DIST_LADD ) : thm = |- !m p n. dist (m + n,m + p) = dist (n,p)
val ( DIST_RADD ) : thm = |- !m p n. dist (m + p,n + p) = dist (m,n)
val ( DIST_LADD_0 ) : thm = |- !m n. dist (m + n,m) = n
val ( DIST_RADD_0 ) : thm = |- !m n. dist (m,m + n) = n
val ( DIST_LMUL ) : thm = |- !m n p. m * dist (n,p) = dist (m * n,m * p)
val ( DIST_RMUL ) : thm = |- !m n p. dist (m,n) * p = dist (m * p,n * p)
val ( DIST_EQ_0 ) : thm = |- !m n. (dist (m,n) = 0) = m = n
val ( DIST_ELIM_THM ) : thm =
  |- P (dist (x,y)) = (!d. ((x = y + d) ==> P d) /\ ((y = x + d) ==> P d))
